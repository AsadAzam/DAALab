# What is Knapsack's Problem
The knapsack problem is a problem in combinatorial optimization: Given a set of items, each with a weight and a value, determine the number of each item to include in a collection so that the total weight is less than or equal to a given limit and the total value is as large as possible. It derives its name from the problem faced by someone who is constrained by a fixed-size knapsack and must fill it with the most valuable items. The problem often arises in resource allocation where the decision makers have to choose from a set of non-divisible projects or tasks under a fixed budget or time constraint, respectively.

The knapsack problem has been studied for more than a century, with early works dating as far back as 1897. The name "knapsack problem" dates back to the early works of the mathematician Tobias Dantzig (1884–1956), and refers to the commonplace problem of packing the most valuable or useful items without overloading the luggage.

### Algorithm
#### Dynamic programming in-advance algorithm[edit]
The unbounded knapsack problem (UKP) places no restriction on the number of copies of each kind of item. Besides, here we assume that 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;{\displaystyle&space;m[w']=\max&space;\left(\sum&space;_{i=1}^{n}v_{i}x_{i}\right)}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;{\displaystyle&space;m[w']=\max&space;\left(\sum&space;_{i=1}^{n}v_{i}x_{i}\right)}" title="{\displaystyle m[w']=\max \left(\sum _{i=1}^{n}v_{i}x_{i}\right)}" /></a>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subject to <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;{\displaystyle&space;\sum&space;_{i=1}^{n}w_{i}x_{i}\leq&space;w'}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;{\displaystyle&space;\sum&space;_{i=1}^{n}w_{i}x_{i}\leq&space;w'}" title="{\displaystyle \sum _{i=1}^{n}w_{i}x_{i}\leq w'}" /></a> and <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;x_i&space;>&space;0" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;x_i&space;>&space;0" title="x_i > 0" /></a>
Observe that <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;m[w]" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;m[w]" title="m[w]" /></a> has the following properties:

1. <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;m[0]=0" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;m[0]=0" title="m[0]=0" /></a>, (the sum of zero items, i.e., the summation of the empty set).

2. <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;{\displaystyle&space;m[w]=\max(v_{1}&plus;m[w-w_{1}],v_{2}&plus;m[w-w_{2}],...,v_{i}&plus;m[w-w_{i}])}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;{\displaystyle&space;m[w]=\max(v_{1}&plus;m[w-w_{1}],v_{2}&plus;m[w-w_{2}],...,v_{i}&plus;m[w-w_{i}])}" title="{\displaystyle m[w]=\max(v_{1}+m[w-w_{1}],v_{2}+m[w-w_{2}],...,v_{i}+m[w-w_{i}])}" /></a>, <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;{\displaystyle&space;w_{i}\leq&space;w}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;{\displaystyle&space;w_{i}\leq&space;w}" title="{\displaystyle w_{i}\leq w}" /></a>, where 
<a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;v_{i}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;v_{i}" title="v_{i}" /></a> is the value of the <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;i" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;i" title="i" /></a>-th kind of item.

The second property needs to be explained in detail. During the process of the running of this method, how do we get the weight <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;w?" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;w?" title="w?" /></a> There are only <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;i" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;i" title="i" /></a> ways and the previous weights are <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;{\displaystyle&space;w-w_{1},w-w_{2},...,w-w_{i}}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;{\displaystyle&space;w-w_{1},w-w_{2},...,w-w_{i}}" title="{\displaystyle w-w_{1},w-w_{2},...,w-w_{i}}" /></a> where there are total <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;i" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;i" title="i" /></a> kinds of different item (by saying different, we mean that the weight and the value are not completely the same). If we know each value of these <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;i" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;i" title="i" /></a> items and the related maximum value previously, we just compare them to each other and get the maximum value ultimately and we are done.

Here the maximum of the empty set is taken to be zero. Tabulating the results from <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;m[0]" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;m[0]" title="m[0]" /></a> up through <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;m[W]" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;m[W]" title="m[W]" /></a> gives the solution. Since the calculation of each <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;m[W]" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;m[W]" title="m[W]" /></a> involves examining at most <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;n" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;n" title="n" /></a> items, and there are at most <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;W" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;W" title="W" /></a> values of <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;m[w]" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;m[w]" title="m[w]" /></a> to calculate, the running time of the dynamic programming solution is <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;O(nW)" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;O(nW)" title="O(nW)" /></a>. Dividing <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;w_{1},\,w_{2},\,\ldots&space;,\,w_{n},\,W" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;w_{1},\,w_{2},\,\ldots&space;,\,w_{n},\,W" title="w_{1},\,w_{2},\,\ldots ,\,w_{n},\,W" /></a> by their greatest common divisor is a way to improve the running time.

Even if P≠NP, the <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;O(nW)" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;O(nW)" title="O(nW)" /></a> complexity does not contradict the fact that the knapsack problem is NP-complete, since <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;W" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;W" title="W" /></a>, unlike <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;n" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;n" title="n" /></a>, is not polynomial in the length of the input to the problem. The length of the <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;W" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;W" title="W" /></a> input to the problem is proportional to the number of bits in <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;W" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;W" title="W" /></a>, <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;\log&space;W" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;\log&space;W" title="\log W" /></a>, not to <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;W" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;W" title="W" /></a> itself. However, since this runtime is pseudopolynomial, this makes the (decision version of the) knapsack problem a weakly NP-complete problem.

#### 0-1 knapsack problem
A similar dynamic programming solution for the 0-1 knapsack problem also runs in pseudo-polynomial time. Assume <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;w_{1},\,w_{2},\,\ldots&space;,\,w_{n},\,W" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;w_{1},\,w_{2},\,\ldots&space;,\,w_{n},\,W" title="w_{1},\,w_{2},\,\ldots ,\,w_{n},\,W" /></a> are strictly positive integers. Define <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;m[i,w]" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;m[i,w]" title="m[i,w]" /></a> to be the maximum value that can be attained with weight less than or equal to <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;w" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;w" title="w" /></a> using items up to <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;i" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;i" title="i" /></a> (first <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;i" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;i" title="i" /></a> items).

We can define <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;m[i,w]" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;m[i,w]" title="m[i,w]" /></a> recursively as follows:

* <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;m[0,\,w]=0" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;m[0,\,w]=0" title="m[0,\,w]=0" /></a>
* <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;m[i,\,w]=m[i-1,\,w]" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;m[i,\,w]=m[i-1,\,w]" title="m[i,\,w]=m[i-1,\,w]" /></a> if <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;w_{i}>w\" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;w_{i}>w\" title="w_{i}>w\" /></a>,\! (the new item is more than the current weight limit)
* <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;m[i,\,w]=\max(m[i-1,\,w],\,m[i-1,w-w_{i}]&plus;v_{i})" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;m[i,\,w]=\max(m[i-1,\,w],\,m[i-1,w-w_{i}]&plus;v_{i})" title="m[i,\,w]=\max(m[i-1,\,w],\,m[i-1,w-w_{i}]+v_{i})" /></a> if <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;w_{i}\leqslant&space;w" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;w_{i}\leqslant&space;w" title="w_{i}\leqslant w" /></a>.
The solution can then be found by calculating <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;m[n,W]" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;m[n,W]" title="m[n,W]" /></a>. To do this efficiently, we can use a table to store previous computations.

##### Greedy approximation algorithm
George Dantzig proposed a greedy approximation algorithm to solve the unbounded knapsack problem. His version sorts the items in decreasing order of value per unit of weight, <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;{\displaystyle&space;v_{1}/w_{1}\geq&space;\cdots&space;\geq&space;v_{n}/w_{n}}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;{\displaystyle&space;v_{1}/w_{1}\geq&space;\cdots&space;\geq&space;v_{n}/w_{n}}" title="{\displaystyle v_{1}/w_{1}\geq \cdots \geq v_{n}/w_{n}}" /></a>. It then proceeds to insert them into the sack, starting with as many copies as possible of the first kind of item until there is no longer space in the sack for more. Provided that there is an unlimited supply of each kind of item, if <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;m" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;m" title="m" /></a> is the maximum value of items that fit into the sack, then the greedy algorithm is guaranteed to achieve at least a value of <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;m/2" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;m/2" title="m/2" /></a>.

For the bounded problem, where the supply of each kind of item is limited, the above algorithm may be far from optimal. Nevertheless a simple modification allows us to solve this case: Construct a solution <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;S_{1}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;S_{1}" title="S_{1}" /></a> by packing items greedily as long as possible, i.e. 
<a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;{\displaystyle&space;S_{1}=\left\{1,\ldots&space;,k\right\}}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;{\displaystyle&space;S_{1}=\left\{1,\ldots&space;,k\right\}}" title="{\displaystyle S_{1}=\left\{1,\ldots ,k\right\}}" /></a> where <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;{\displaystyle&space;k=\textstyle&space;\max&space;_{1\leq&space;k'\leq&space;n}\textstyle&space;\sum&space;_{i=1}^{k}w_{i}\leq&space;W}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;{\displaystyle&space;k=\textstyle&space;\max&space;_{1\leq&space;k'\leq&space;n}\textstyle&space;\sum&space;_{i=1}^{k}w_{i}\leq&space;W}" title="{\displaystyle k=\textstyle \max _{1\leq k'\leq n}\textstyle \sum _{i=1}^{k}w_{i}\leq W}" /></a>. Furthermore, construct a second solution <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;{\displaystyle&space;S_{2}=\left\{k&plus;1\right\}}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;{\displaystyle&space;S_{2}=\left\{k&plus;1\right\}}" title="{\displaystyle S_{2}=\left\{k+1\right\}}" /></a> containing the first item that did not fit. Since <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;{\displaystyle&space;S_{1}\cup&space;S_{2}}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;{\displaystyle&space;S_{1}\cup&space;S_{2}}" title="{\displaystyle S_{1}\cup S_{2}}" /></a> provides an upper bound for the LP relaxation of the problem, one of the sets must have value at least <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;m/2" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;m/2" title="m/2" /></a>; we thus return whichever of <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;S_{1}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;S_{1}" title="S_{1}" /></a> and <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;S_{1}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;S_{2}" title="S_{2}" /></a> has better value to obtain a <a href="https://www.codecogs.com/eqnedit.php?latex=\fn_phv&space;1/2" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\fn_phv&space;1/2" title="1/2" /></a>-approximation.

### Analysis
The knapsack problem is interesting from the perspective of computer science for many reasons:

* The decision problem form of the knapsack problem (Can a value of at least V be achieved without exceeding the weight W?) is NP-complete, thus there is no known algorithm both correct and fast (polynomial-time) in all cases.
* While the decision problem is NP-complete, the optimization problem is not, its resolution is at least as difficult as the decision problem, and there is no known polynomial algorithm which can tell, given a solution, whether it is optimal (which would mean that there is no solution with a larger V, thus solving the NP-complete decision problem).
* There is a pseudo-polynomial time algorithm using dynamic programming.
* There is a fully polynomial-time approximation scheme, which uses the pseudo-polynomial time algorithm as a subroutine, described below.
* Many cases that arise in practice, and "random instances" from some distributions, can nonetheless be solved exactly.

There is a link between the "decision" and "optimization" problems in that if there exists a polynomial algorithm that solves the "decision" problem, then one can find the maximum value for the optimization problem in polynomial time by applying this algorithm iteratively while increasing the value of k . On the other hand, if an algorithm finds the optimal value of the optimization problem in polynomial time, then the decision problem can be solved in polynomial time by comparing the value of the solution output by this algorithm with the value of k . Thus, both versions of the problem are of similar difficulty.

One theme in research literature is to identify what the "hard" instances of the knapsack problem look like, or viewed another way, to identify what properties of instances in practice might make them more amenable than their worst-case NP-complete behaviour suggests.[11] The goal in finding these "hard" instances is for their use in public key cryptography systems, such as the Merkle-Hellman knapsack cryptosystem.

Furthermore, notable is the fact that the hardness of the knapsack problem depends on the form of the input. If the weights and profits are given as integers, it is weakly NP-complete, while it is strongly NP-complete if the weights and profits are given as rational numbers.[12] However, in the case of rational weights and profits it still admits a fully polynomial-time approximation scheme.